<%@ Template Language="C#" TargetLanguage="C#" Debug="True" Encoding="UTF-8" %>

<%@ Assembly Src="Model.cs" %>
<%@ Assembly Src="Extensions.cs" %>

<%@ Import Namespace="System.Collections.Generic" %>
<%@ Import Namespace="System.Linq" %>
<%@ Import Namespace="System.Text" %>
<%@ Import Namespace="System.Text.RegularExpressions" %>

<%@ Import Namespace="SchemaMapper" %>

<%@ Property Name="EntityContext" Type="SchemaMapper.EntityContext"  %>
<%@ Property Name="ContextClassName" Type="System.String"  %>

<%@ Property Name="MockNamespace" Type="System.String"  %>
<%@ Property Name="ContextNamespace" Type="System.String"  %>
<%@ Property Name="EntityNamespace" Type="System.String"  %>
<%@ Property Name="MappingNamespace" Type="System.String"  %>
<%@ Property Name="Internalize" Type="Boolean" %>

//------------------------------------------------------------------------------
// <autogenerated>
//     This code was generated by a CodeSmith Template.
//
//     DO NOT MODIFY contents of this file. Changes to this
//     file will be lost if the code is regenerated.
// </autogenerated>
//------------------------------------------------------------------------------
using System;
using System.Collections.Generic;
using System.Linq;
using System.Linq.Expressions;

namespace <%= MockNamespace %>
{
    <%= Internalize ? "internal" : "public" %> sealed partial class Fake<%= ContextClassName.ToSafeName() %>
        : <%= ContextNamespace %>.I<%= ContextClassName.ToSafeName() %>
    {        
        public Fake<%= ContextClassName.ToSafeName() %>()
        {
<% foreach(var p in EntityContext.Entities) { %>
            <%= p.ContextName.ToSafeName() %> = new FakeDbSet<<%= EntityNamespace %>.<%= p.ClassName.ToSafeName() %>><%= FindExpression(p) %>;
<% } // foreach %>        
        }

<% foreach(var p in EntityContext.Entities) { %>
        public System.Data.Entity.IDbSet<<%= EntityNamespace %>.<%= p.ClassName.ToSafeName() %>> <%= p.ContextName.ToSafeName() %> { get; set; }
<% } // foreach %>

        public System.Data.Entity.IDbSet<TEntity> Set<TEntity>() where TEntity : class
        {
            return GetType().GetProperties()
                .Where(p => p.PropertyType == typeof(System.Data.Entity.IDbSet<TEntity>))
                .Select(p => p.GetValue(this, null) as System.Data.Entity.IDbSet<TEntity>)
                .Single();
        }

        public int SaveChanges()
        {
            return 0;
        }

        public void Dispose()
        {
        }

        #region NotImplementedException
        public System.Data.Entity.Database Database
        {
            get { throw new NotImplementedException(); }
        }

        public System.Data.Entity.Infrastructure.DbChangeTracker ChangeTracker
        {
            get { throw new NotImplementedException(); }
        }

        public System.Data.Entity.Infrastructure.DbContextConfiguration Configuration
        {
            get { throw new NotImplementedException(); }
        }

        public System.Data.Entity.Infrastructure.DbEntityEntry Entry(object entity)
        {
            throw new NotImplementedException();
        }

        public System.Data.Entity.Infrastructure.DbEntityEntry<TEntity> Entry<TEntity>(TEntity entity) where TEntity : class
        {
            throw new NotImplementedException();
        }

        public IEnumerable<System.Data.Entity.Validation.DbEntityValidationResult> GetValidationErrors()
        {
            throw new NotImplementedException();
        }

        public System.Data.Entity.DbSet Set(Type entityType)
        {
            throw new NotImplementedException();
        }
        #endregion
    }
    
    <%= Internalize ? "internal" : "public" %> partial class FakeDbSet<TEntity>
        : System.Data.Entity.IDbSet<TEntity> where TEntity : class
    {
        private readonly System.Collections.ObjectModel.ObservableCollection<TEntity> _data;
        private readonly IQueryable<TEntity> _query;

        public FakeDbSet()
        {
            _data = new System.Collections.ObjectModel.ObservableCollection<TEntity>();
            _query = _data.AsQueryable();
        }

        public Func<object[], Expression<Func<TEntity, bool>>> FindExpression { get; set; }

        public virtual TEntity Find(params object[] keyValues)
        {
            if (FindExpression == null)
                throw new NotImplementedException();

            return _query.SingleOrDefault(FindExpression(keyValues));
        }

        public TEntity Add(TEntity item)
        {
            _data.Add(item);
            return item;
        }

        public TEntity Remove(TEntity item)
        {
            _data.Remove(item);
            return item;
        }

        public TEntity Attach(TEntity item)
        {
            _data.Add(item);
            return item;
        }

        public void Detach(TEntity item)
        {
            _data.Remove(item);
        }

        Type IQueryable.ElementType
        {
            get { return _query.ElementType; }
        }

        Expression IQueryable.Expression
        {
            get { return _query.Expression; }
        }

        IQueryProvider IQueryable.Provider
        {
            get { return _query.Provider; }
        }

        System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
        {
            return _data.GetEnumerator();
        }

        IEnumerator<TEntity> IEnumerable<TEntity>.GetEnumerator()
        {
            return _data.GetEnumerator();
        }

        public TEntity Create()
        {
            return Activator.CreateInstance<TEntity>();
        }

        public System.Collections.ObjectModel.ObservableCollection<TEntity> Local
        {
            get { return _data; }
        }

        public TDerivedEntity Create<TDerivedEntity>()
            where TDerivedEntity : class, TEntity
        {
            return Activator.CreateInstance<TDerivedEntity>();
        }
    }
}

<script runat="template">
public string FindExpression(Entity entity)
{
    var keys = entity.Properties.PrimaryKeys;
    if (keys.Count() == 0)
        return "()";
    
    // { FindExpression = v => e => e.Id == (int)v[0] }
    StringBuilder sb = new StringBuilder();
    sb.Append(" { FindExpression = v => e => ");
        
    int c = 0;
    foreach(var p in keys)
    {
        if (c > 0)
            sb.Append(" && ");
        
        string name = p.PropertyName.ToSafeName();
        string type = p.SystemType.ToNullableType(p.IsNullable == true);
        
        sb.Append("e.");
        sb.Append(name);
        sb.Append(" == (");
        sb.Append(type);
        sb.Append(")v[");
        sb.Append(c++);
        sb.Append("]");
    }
    sb.Append(" }");

    return sb.ToString();
}
</script>